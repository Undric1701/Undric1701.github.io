<!-- Treatykov Andrey (AT7), 10-7, 04.06.2025, Platon's figures task -->

<!DOCTYPE html>
<html>

<head>
    <script type="module" , src="mth.js"></script>
    <script type="module">
        import * as mth from "./mth.js"
        let gl;
        let startTime, pausetime = 0.0;
        let FrameW, FrameH;
        let IsPause = false;
        let ProjSize = 0.1;

        function initGL(canvas) {
            gl = canvas.getContext("webgl2");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
            FrameW = canvas.width;
            FrameH = canvas.height;
        }

        const shaderFs = `#version 300 es
        precision highp float;

        layout (location = 0) out vec4 o_color;
                             
        uniform float u_time;
        uniform float FrameW;
        uniform float FrameH;

        void main() {
            o_color = vec4(1, 0, 0, 1);
        }`;

        const shaderVs = `#version 300 es
        precision highp float;
        uniform mat4 MatrVP;

        layout (location = 0) in vec3 a_pos;

        void main() {
            gl_Position = /*MatrVP * */vec4(a_pos, 1);
        }`;

        function getShader(shaderStr, type) {
            const shader = gl.createShader(type);

            gl.shaderSource(shader, shaderStr);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
            }

            return shader;
        }

        let u_time_location,
            u_frame_w_location,
            u_frame_h_location,
            u_posx_location,
            u_posy_location,
            u_frac_location,
            u_iterations_location,
            u_zoom_location,
            u_background_color,
            u_fractal_color,
            u_matrVP_location;

        function GetColor(Color) {
            let r = parseInt(Color.substring(1, 3), 16) / 255.0;
            let g = parseInt(Color.substring(3, 5), 16) / 255.0;
            let b = parseInt(Color.substring(5, 7), 16) / 255.0;
            return [r, g, b];
        }

        function initShaders() {
            const vs = getShader(shaderFs, gl.FRAGMENT_SHADER);
            const fs = getShader(shaderVs, gl.VERTEX_SHADER);

            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                alert("Program linkage error");
            }

            gl.useProgram(program);

            u_time_location = gl.getUniformLocation(program, "u_time");
            u_frame_w_location = gl.getUniformLocation(program, "FrameW");
            u_frame_h_location = gl.getUniformLocation(program, "FrameH");
            u_posx_location = gl.getUniformLocation(program, "POSX");
            u_posy_location = gl.getUniformLocation(program, "POSY");
            u_frac_location = gl.getUniformLocation(program, "frac");
            u_iterations_location = gl.getUniformLocation(program, "Iterations");
            u_zoom_location = gl.getUniformLocation(program, "Zoom");
            u_background_color = gl.getUniformLocation(program, "BackgroundColor");
            u_fractal_color = gl.getUniformLocation(program, "FractalColor");
            u_matrVP_location = gl.getUniformLocation(program, "MatrVP");
        }

        let vertexBuffer;
        function initBuffer() {
            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            const vertices = [3, 1, -1, -1, 1, 1, -1, -3, 2];
            gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array(vertices),
                gl.STATIC_DRAW
            );
        }

        function drawScene() {
            let timeFromStart = 0;

            if (IsPause)
                timeFromStart = pausetime;
            else
                timeFromStart = (new Date()).getMilliseconds() - startTime - pausetime;

            gl.clearColor(0, 0, 1, 1);
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

            //let loc = new mth.VEC3(30 * Math.sin(timeFromStart / 500 * mth.PI), 30, 30 * Math.cos(timeFromStart / 500 * mth.PI));
            let loc = new mth.VEC3(30, 30, 30);
            let at = new mth.VEC3(0, 0, 0);
            let up = new mth.VEC3(0, 1, 0);
            let MatrV = mth.MatrView(loc, at, up);
            let MatrP = mth.MatrFrustum(-ProjSize / 2, ProjSize / 2, -ProjSize / 2, ProjSize / 2, 0.1, 100);
            let MatrVP = mth.MatrMulMatr(MatrV, MatrP);
            timeFromStart = 0;
            let p1 = new mth.VEC3(5 + 10 * Math.sin(timeFromStart / 500 * mth.PI), 10, 5 + 10 * Math.cos(timeFromStart / 500 * mth.PI));
            let p2 = new mth.VEC3(10 + 10 * Math.sin(timeFromStart / 500 * mth.PI), 0, 10 + 10 * Math.cos(timeFromStart / 500 * mth.PI));
            let p3 = new mth.VEC3(2 + 10 * Math.sin(timeFromStart / 500 * mth.PI), 10, -10 + 10 * Math.cos(timeFromStart / 500 * mth.PI));
            p1 = mth.Vec3MulMatr(p1, MatrVP);
            p2 = mth.Vec3MulMatr(p2, MatrVP);
            p3 = mth.Vec3MulMatr(p3, MatrVP);
            //p1 = mth.Vec3AddVec3(mth.Vec3Set(0.5, 0.5, 0.5), mth.Vec3MulNum(p1, 0.5));
            //p2 = mth.Vec3AddVec3(mth.Vec3Set(0.5, 0.5, 0.5), mth.Vec3MulNum(p2, 0.5));
            //p3 = mth.Vec3AddVec3(mth.Vec3Set(0.5, 0.5, 0.5), mth.Vec3MulNum(p3, 0.5));
            let points = [p1.X, p1.Y, p1.Z, p2.X, p2.Y, p2.Z, p3.X, p2.Y, p3.Z];
            points = new Float32Array(points);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(
                gl.ARRAY_BUFFER,
                points,
                gl.STATIC_DRAW
            );

            if (IsPause)
                timeFromStart = pausetime;
            else
                timeFromStart = (new Date()).getMilliseconds() - startTime - pausetime;

            gl.uniform1f(u_time_location, timeFromStart / 1000.0);
            gl.uniform1f(u_frame_w_location, FrameW);
            gl.uniform1f(u_frame_h_location, FrameH);
            gl.uniformMatrix4fv(u_matrVP_location, true, new Float32Array(MatrVP.A[0].concat(MatrVP.A[1].concat(MatrVP.A[2].concat(MatrVP.A[3]))), 0, 16));

            gl.drawArrays(gl.TRIANGLES, 0, 3);
            window.requestAnimationFrame(drawScene);
        }

        function onStart() {
            console.log("AT7 Platon's figures task");
            let mult = 0.00047;

            let canvas = document.getElementById("webgl-canvas");

            let v1 = mth.Vec3Set(1, 2, 3);
            let v2 = mth.Vec3Set(4, 5, 6);
            let v3 = mth.Vec3AddVec3(v1, v2);

            console.log(v3.X, v3.Y, v3.Z);

            initGL(canvas);
            initShaders();
            initBuffer();

            startTime = (new Date()).getMilliseconds();
            drawScene();
        }
        window.addEventListener("load", () => { onStart() });
    </script>
</head>

<body>
    <canvas id="webgl-canvas" style="border: none" width="1000" height="1000"></canvas>
</body>

</html>